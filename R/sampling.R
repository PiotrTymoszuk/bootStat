# Functions for sampling of a data frame or a vector

#' Bootstrap samples a vector, matrix or a data frame
#'
#' @description
#' Creates a given number of bootstrap samples of a vector or a data frame.
#'
#' @details
#' The bootstraps are generated by drawing random samples of indexes (vector)
#' or row indexes (matrix or data frame) with replacement.
#' Specifically for data frames, the user may specify one or more columns
#' used to defined blocks used for block bootstrap. In such approach, levels
#' of the block structure (e.g. unique participant ID in a repeated measurement
#' data set) are sampled instead of observations. This option offers a
#' possibility to handle non-independently distributed or auto-correlated
#' observations.
#' The function `sboot()` is a S3 generic.
#' Works in parallel, if a parallel backend is registered via `future::plan()`.
#'
#' @returns a named list of vectors, matrices or data frames named with the
#' `boot_n` scheme, where `n` denotes the sample number.
#'
#' @param x an object, currently a vector (default), matrix or a data frame.
#' @param B an integer, the number of bootstrapped samples to be returned.
#' @param .by a character vector of column names which defines blocks
#' in block bootstrap. Ignored if `NULL`: classical bootstrap.
#' @param .drop logical, should empty vector in the block structure be removed?
#' Defaults to `TRUE`. Ignored if `.by` is set to `NULL`.
#' @param ... extra arguments passed to the methods.
#'
#' @export

  sboot <- function(x, B, ...) UseMethod('sboot')

#' @rdname sboot
#' @export sboot.default
#' @export

  sboot.default <- function(x, B, ...) {

    ## handles atomic vectors

    if(!is.atomic(x)) {

      stop("'x' has to be an atomic vector.", call. = FALSE)

    }

    stopifnot(is.numeric(B))

    B <- as.integer(B)

    vec_samples <-
      purrr::map(1:B, function(i) sample(x, length(x), replace = TRUE))

    rlang::set_names(vec_samples, paste0('boot_', 1:B))

  }

#' @rdname sboot
#' @export sboot.matrix
#' @export

  sboot.matrix <- function(x, B, ...) {

    ## handles matrices

    #if(!is.matrix(x)) stop("'x' has to be a matrix.", call. = FALSE)

    stopifnot(is.numeric(B))

    B <- as.integer(B)

    indexes <- 1:nrow(x)

    index_samples <- sboot(indexes, B = B)

    furrr::future_map(index_samples, ~x[.x, ])

  }

#' @rdname sboot
#' @export sboot.data.frame
#' @export

  sboot.data.frame <- function(x, B, .by = NULL, .drop = TRUE, ...) {

    ## no block bootstrap -----

    if(is.null(.by)) return(sboot.matrix(x, B))

    ## entry control for the block-defining variables ------

    stopifnot(is.character(.by))

    if(any(!.by %in% names(x))) {

      stop(paste("At least one of the variables precified by '.by' is',
                 'missing from the data frame."),
           call. = FALSE)

    }

    sel_frame <- dplyr::select(x, dplyr::all_of(.by))

    sel_vec <- interaction(as.list(sel_frame), drop = .drop)

    .observation <- NULL
    .id <- NULL

    sel_frame <- dplyr::mutate(sel_frame,
                               .observation = 1:nrow(sel_frame),
                               .id = sel_vec)

    ## resampling of the unique levels of the block structure -------

    ## warning: some levels may be duplicated in the resamples!!!
    ## I need to account for that fact in the output data frames

    sel_vec <- sboot(as.character(unique(sel_vec)), B = B)

    boot_frame <-
      furrr::future_map(sel_vec,
                        filter_repeated,
                        data = sel_frame,
                        variable = '.id')

    purrr::map(boot_frame, ~x[.x$.observation, ])

  }

# END -----
